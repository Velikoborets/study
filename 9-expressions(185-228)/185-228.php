
<?php

/***** ВВЕДЕНИЕ В РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ В PHP 185/228 ✓ *****/

// Регулярные выражения - команды для сложного поиска и замены.

// В РНР сущ. несколько фу-ий для работы с рег. выражениями.
// Начнем с preg_replace;

// preg_replace(что менять, на что, строка где заменять); 

// при этом первым парам. фу-я прин. не просто строку
// а РЕГУЛЯРНОЕ ВЫРАЖЕНИЕ представляющее собой строку
// с набором кооманд расположеных внутри символа #
// # -  ограничитель регулярных выражений.

// после # можно писать модификаторы, команды, которые
// изменяют общие св-ва регулярного выражения.

// Регуляр. выраж. сост. из 2х типов символов:
// 1. Те которые обозначают сами себя (буквы и цифры)
// 2. И символовы-команды т.е  "специальные символы".

// "."(точка) -  обозначает любой символ. (не яв. специальным).
// Пример:

// preg_replace('#x.x#', '!', 'xAx'); // на выводе - "!"

// 1. В "# #" мы ук. по сути усл. что меняем по бокам - "х";
// 2. А между "#x.x#" иксами - ".", т.е любой символ
// 3. И всё это меняю например на "xAx".
// 4. Условия соблюденые, в результате у нас "!"
// 5. Т.е, то что мы ук, чтобы заменить то, что у нас в "# #".


# ДЗ (Введение в регулярные выражения в PHP):

# №1
# Напишите регулярку, которая найдет строки 'ahb', 'acb', 'aeb'
# по шаблону: буква 'a', любой символ, буква 'b'.

# $str = 'ahb acb aeb aeeb adcb axeb';
# echo preg_replace('#a.b#', '!this', "$str"); 

# На выводе - !this !this !this aeeb adcb axeb

# Мы видим, что регулярка, проверила нашу большую строку
# И отметила строки с помощью "!this" котор. мы указ. В # #

# №2
# Напишите регулярку, которая найдет строки 'abba', 'adca', 
# 'abea'  по шаблону: буква 'a', два любых символа, буква 'b'.
# $str = 'ahb acb aeb aeeb adcb axeb';
# echo preg_replace('#a..b#', '!this', "$str");



/**** ОПЕРАТОРЫ ПОВТОРЕНИЯ СИМВОЛОВ В РЕГУЛЯРКАХ 186/228  ✓ ****/

// Иногда, нам надо знать, сколько раз повторяется символ.
// Для этого сущ. квантификаторы(операторы) повторения:

// + - один(1) и более раз
// * - ноль(0) и более раз
// ? - ноль(0) или один раз

// Эти операторы ДЕЙСТВУЮТ НА ТОТ СИМВОЛ, КОТ. СТОИТ ПЕРЕД НИМИ

// Пример(1):
// Найдем все подстроки по шаблону буква 'x', 
// буква 'a', один или более раз, буква 'x'
// $str = 'xx xax xaax xaaax xbx';   
// пишем "а+" т.е применяем квантификатор "+" к "а"
// echo $res = preg_replace ('#xa+x#', '!', "$str");
// xx ! ! ! xbx'

// Пример(2):
// Найдем все подстроки по шаблону буква 'x',
// буква 'a', ноль или более раз, буква 'x':
// $str = 'xx xax xaax xaaabb xbx';
// пишем "а*" т.е применяем квантификатор "*" к "а"
// echo preg_replace('#xa*x#','!', "$str"); 
// '! ! ! ! xbx'

// Пример(3):
// Найдем все подстроки по шаблону буква 'x'
// буква 'a' ноль или один раз, буква 'x'
// $str = 'xx xax xaax xaaax xbx';
// пишем "а?" т.е применяем квантификатор "?" к "а"
// preg_replace('#xa?x#','!', "$str");
// '! ! xaax xbx'

# ДЗ (ОПЕРАТОРЫ ПОВТОРЕНИЯ СИМВОЛОВ В РЕГУЛЯРКАХ):

# №1
# Напишите регулярку, которая найдет строки по шаблону:
# буква 'a', буква 'b' один или более раз, буква 'a'.
# $str = 'aa aba abba abbba abca abea';
# echo preg_replace('#ab+a#', '!', "$str"); 
# aa!!!abca abea 
# т.к : аа - b нет, abca - есть с, abea - есть е; 

# №2
# Напишите регулярку, которая найдет строки по шаблону:
# буква 'a', буква 'b' ноль или более раз, буква 'a'.
# $str = 'aa aba abba abbba abca abea';
# echo preg_replace('#ab*a#', '!', "$str"). '<br>';
# ! ! ! ! abca abea

# №3
# Напишите регулярку, которая найдет строки по шаблону:
# буква 'a', буква 'b' один или ниодного, буква 'a'.
# $str = 'aa aba abba abbba abca abea';
# echo preg_replace('#ab?a#', '!', "$str") . '<br>'; 
# ! ! abba abbba abca abea

# №4
# Напишите регулярку, которая найдет строки 
# 'aa', 'aba', 'abba', 'abbba', не захватив 'abca' и 'abea'.
# $str = 'aa aba abba abbba abca abea';
# echo preg_replace('#ab*a#', '!', "$str");

# когда строки захваченые - они заменяются на "!";
# регулярка - захватывает регулярное выражение, поэтому
# они и называются - регулярки, потому, что регулярно встреч.



/*** ГРУППИРУЮЩИЕ СКОБКИ В РЕГУЛЯРКАХ PHP 187/228 ✓ ***/

// () - если после них стоит, оператор повторения(квантификатор)
// то он подействует на всё, что в скобках

// $str = 'xabx xababx xaabbx';
// $res = preg_replace('#x(ab)+x#', '!', $str);
// '! ! xaabbx'
// т.к  по бокам у "ab" не "х",  т.е а "ab b" вместо "х ab х" 
// как указано в разделителях 

# ДЗ (Группирующие скобки в регулярках PHP)
# № 1
# Напишите регулярку, которая найдет строки по шаблону:
# строка 'ab' повторяется 1 или более раз.
# $str = 'ab abab abab abababab abea';
# echo preg_replace('#(ab)+#', '!', "$str"); // ! ! ! ! !ea



/*** ЭКРАНИРОВКА СПЕЦСИМВОЛОВ В РЕГУЛЯРКАХ PHP 188/228 ✓ ***/

// Пример(1):
// допустим надо найти такую строку по шаблону:
// "буква а ", "плюс", "буква х" - т.е а+х

// окей, напишем это:
// $str = 'a+x ax aax aaax';
// echo $res = preg_replace('#a+x#', '!', $str);
// Результат будет: "a+x ! ! !",  т.к не проэкранирован "+";

// Пример(2):
// теперь заэкранируем наш "+":
// $str = 'a+x ax aax aaax';
// $res = preg_replace('#a\+x#', '!', $str);
//  Результат будет: '! ax aax aaax', т.к теперь искали "а+х"

// Пример(3):
// найдем строку "а.х" 
// $str = 'a.x abx azx';
// echo preg_replace('#a\.x#', '!', "$str");
// ! abx azx  // ТОЧКА в эт. примере ЯВ. Т 



/* СПИСОК СПЕЦИАЛЬНЫХ СИМВОЛОВ В РЕГУЛЯРКАХ В PHP 189/228 ✓ */

// Если экранировать символ - все также будет обозн. сам себя.
// Цифры экранировать нельзя.
// Являются спецсимволами: $ ^ . * + ? \ / {} [] () |
// (все слеши, скобки, милота, доллар ну котор. уже знаю)

# ДЗ (спец.символы):

# 1
# напишите регулярку, которая найдет строку 'a.a', не
# захватив остальные.
# $str = 'a.a aba aea';
# echo preg_replace('#a\.a#', '!', "$str");

# 2
# Напишите регулярку, 
# которая найдет строку '2+3', не захватив остальные.
# $str = '2+3 223 2223';
# echo preg_replace('#2\+3#', '!',"$str");

# 3
# Напишите регулярку котор. найдет строки
# '2+3', '2++3', '2+++3', 
# не захватив остальные (+ может быть любое количество).
# $str = '23 2+3 2++3 2+++3 345 567';
# echo preg_replace('#2\++3#', '!', "$str");

# 4
# Найти строки '23', '2+3', '2++3', '2+++3',
# $str = '23 2+3 2++3 2+++3 445 677';
# echo preg_replace('#2\+*3#', '!', "$str");

# 5
# Найти строки '*q+', '*qq+', '*qqq+';
# $str = '*+ *q+ *qq+ *qqq+ *qqq qqq+';
# echo preg_replace('#(\*q+\+)+#','!', "$str");

# 6 
# $str = '[abc] {abc} abc (abc) [abc]'; 
# echo preg_replace('#(abc)+#', '!', "$str");



/* ФИГУРНЫЕ СКОБКИ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯ PHP 190/228 ✓ */

// {} - с их помощью можно указать конкретное число повторений.
// {5} - пять повторений.
// {2,5} - от 2х до 5, оба включительно.
// {2,} - повторяется два и более раз.	

// ex1
// x, "a" один или два раза, x
// $str = 'xx xax xaax xaaax';
// echo preg_replace('#xa{1,2}x#', '!',"$str");

// ex2
// буква 'x', буква 'a' два раза и более, буква 'x'
// $str = 'xx xax xaax xaaax';
// echo preg_replace('#xa{2,}x#', '!', "$str");

// ex3
// буква 'x', буква 'a' три раза, буква 'x':
// $str = 'xx xax xaax xaaax';
// echo preg_replace('#xa{3}x#', '!',"$str");

// ex4
// буква "а" десять раз.
// $str = 'aaa aaaaaaaaaa aaa';
// echo $res = preg_replace('#a{10}#', '!', $str);

// ex4
// буква "а" от нуля до трёх раз.
// $str = 'xx xax xaax xaaax';
// $res = preg_replace('#xa{0,3}x#', '!', $str);

# ДЗ (ФИГУРНЫЕ СКОБКИ):

# №1
# Найдите строки  'abba', 'abbba', 'abbbba' и только их!
# $str = 'aa aba abba abbba abbbba abbbbba'; 
# echo preg_replace('#ab{2,4}a#', '!', "$str");

# №2
# aba, b менее трех раз включительно
# $str = 'aa aba abba abbba abbbba abbbbba'; 
# echo preg_replace('#ab{0,3}a#', '!', "$str");

# №3
# aba, где b встречается более четырех раз
# $str = 'aa aba abba abbba abbbba abbbbba'; 
# echo preg_replace('#ab{4,}a#', '!', "$str");



/* ОГРАНИЧЕНИЕ ЖАДНОСТИ В РЕГУЛЯРКАХ В PHP 191/228  ✓ */

// Регулярные выражения захватывают по умолчанию max. кол-во симв.

// Например:
// буква а, затем любой символ один или более раз, буква х
// $str = 'aeeex zzz x kkk';
// echo preg_replace('#a.+x#', '!', "$str");

// мы ожидаем ответ : ! zzz x kkk
// а получим ответ: ! kkk
// 
// т.к регулярка, по умолчанию - жадная
// она ищет до последнего "x"

// чтобы ограничить поиск до первого "х" исп. знак "?"
// echo preg_replace('#a.+?x#', '!', "$str");

// жадность можно ограничивать всем операторам повторения:
// *?, ?? и {}?.

// ДЗ(огр.жад. в рег.):
// №1
// найти все строки по краям кот. стоят буквы "а",
// заменить их все (эти строки) на !
// между "а", может быть любой символ, кроме "а"
// $str = 'aba accca azzza wwwwa';
// echo preg_replace('#a.+?a#', '!', "$str");



/** ГРУППЫ СИМВОЛОВ В РЕГУЛЯРКАХ В PHP 192/228 ✓ **/

// Можно сразу выбрать ГРУППУ СИМВОЛОВ:

//  "\d" - цифра от 0 до 9.
//  "\w" - цифра, лат.буква или знак "_"
//  "\s" - пробел или пробельный символ.
//  "\D" - инвертируем "d", и уже, не цифра.

// Пример1 найдем все цифры:
// $str = '1 12 123';
// echo preg_replace('#\d#', '!', "$str");

// Пример2 
// опер. повт. считают ком.-груп. одним целым
// т.е груп.скобки() не нужны.
// цифра от 0 до 9 один или более раз:
// $str = '1 12 123 abc @@@';
// echo preg_replace('#\d+#', '!', "$str");

// Пример3
// Всё, что угодно 1 или более раз но не цифра от 0 до 9:
// $str = '123abc3@@';
// $res = preg_replace('#\D#', '!', "$str"); // '123!3!'

// Пример4
// пробельный символ 1 раз.
// $str = '1 12 123 abc @@@';
// echo $res = preg_replace('#\s#', '!', "$str");

// Пример5
// НЕ пробельный один или более 1 раз.
// $str = '1 12 123 abc @@@';
// echo $res = preg_replace('#\S#', '!', "$str");

// Пример6
// цифра или буква один или более раз.
// не цифра и не буква, соотв. W
// $str = '1 12 123 abc @@@';
// echo $res = preg_replace('#\w#', '!', "$str");

# ДЗ (группы символов)

# 1
# найти строки где по краям "а", между ними - 1 цифра.
# $str = 'a1a a2a a3a a4a a5a aba aca';
# echo preg_replace('#a\da#', '!', "$str");

# 2
# найти строки где по краям "а", между ними - любое кол-во цифр.
# $str = 'a1a a22a a333a a4444a a55555a aba aca';
# echo preg_replace('#a\d+a#', '!', "$str");

# 3
# найти строки где по краям "а", между ними - любое кол-во цифр.
# $str = 'aa a1a a22a a333a a4444a a55555a aba aca'; 
# echo preg_replace('#a\d+a#', '!', "$str");

# 4
# по краям строки a и b, между ними - не число
# $str = 'avb a1b a2b a3b a4b a5b abb acb';
# echo preg_replace('#a\Db#', '!', "$str");

# 5
# по краям строки a и b, между ними - не буква и не цифра.
# $str = 'ave a#b a2b a$b a4b a5b a-b acb';
# echo preg_replace('#a\Wb#', '!', "$str");

# 6
# регулярка, кот. заменит все пробелы на "!"
# $str = 'ave a#a a2a a$a a4a a5a a-a aca';
# echo preg_replace('#\s#', ' ! ', "$str");



/** НАБОРЫ СИМВОЛОВ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ PHP 193/228 ✓ **/

// "\d" и "\w" - группы символов не очень гибкие.
// [ ] - предств. собой операцию ИЛИ

// Пример:
// #x[abc]x# - мы говорим, что по краям должны стоять "х"
// А внутри - один символ или а или b или с .

// Пример2 можно создавать группы символов:
// #x[a-d]x# - получаем все символы от а до d.
// #x[A-Z]x# - получ. все символы от A до Z.  Между "х" в верх. рег.
// #x[2-9]x# - между х, любая цифра от 2 до 9.

// когда условий больше одного, то прога выполняет оба условия.
// (т.е найдет и то и то):
// #x[a-z,1-9]x# - между х, буква а-z, или цифра 1-9 
// #x[a-z,А-Z]x# - между х, буква а-z, или буква А-Z 
// #x[a-z,1,2]x# - между х, буква а-z, или цифра 1,2 
// #x[a-z]+x# - между х, буквы от а до z, в кол-ве от 1 и более:
// #x[1-9]+x# - между х, цифры от 1 до 9, в кол-ве от 1 и более:
// #x[a-z]*x# - между х, кол-во букв 0 и более


# ДЗ (Наборы символов):

# 1
# по краяем а, между ними b, e, или х
# $str = 'aba aea aca aza axa';
# echo preg_replace('#a[bex]a#', '!', "$str");

# 2 
# а по краям, между а - цифра от 3х до 6ти
# $str = 'a1a a3a a7a a9a aba';
# echo preg_replace('#a[3,6]a#', '!', "$str");

# 3
# а по краям, между - а до g
# $str = 'aba aea afa aha aga';
# echo preg_replace('#a[a-g]a#', '!', "$str");

# 4
# а по краям, между - а до g
# $str = 'aba aea afa aha aga';
# echo preg_replace('#a[a-f,j-z]a#', '!', "$str");

# 5
# а по краям, между - а до f и от А до E
# $str = 'aAa aea aEa aJa a3a';
# echo preg_replace('#a[a-f,A-E]a#', '!', "$str");

# 6
# а по краям, между - мал. латинские буквы
# $str = 'aAXa aeffa aGha aza ax23a a3sSa';
# echo preg_replace('#a[a-z]+a#', '!', "$str");

# 7
# по краям - а, между ними маленькие и большие лат.буквы без ост.
# $str = 'aAXa aeffa aGha aza ax23a a3sSa';
# echo preg_replace('#a[a-z,A-Z]+a#', '!', "$str");

# 8
# а по краям, между - мал. лат. буквыи и цифры, без ост.
# $str = 'aAXa aeffa aGha aza ax23a a3sSa'; 
# echo preg_replace('#a[a-z,1-9]+a#', '!', "$str");



/** ИНВЕРТИРОВАНИЕ НАБОРОВ СИМВОЛОВ В РЕГУЛЯРКАХ PHP 194/228 ✓ **/

// ^ - инвертирует набор символов. Пример:
// [ab]  - ищет только а и b 
// [^ab] - ищет всё кроме а и b

// Пример1
// х, не a b с, потом z
// $str = 'xaz xbz xcz xez';
// echo preg_replace('#x[^abc]z#', '!', "$str");

// Пример2
// буква 'x', затем НЕ маленькая латинская буква, потом буква 'z':
// $str = 'xaz xbz x1z xCz';
// preg_replace('#x[^a-z]z#', '!', $str);


# ДЗ (инвертирование набора символов в регулярках):

# 1
# найти 1, не - е х , 2
# $str = '1a2 1b2 1e2 1x2';
# echo preg_replace('#1[^ex]2#', '!', "$str");

# 2
# найти х, не 2 до 7, z
# $str = 'x2z xbz x1z x7z';
# echo preg_replace('#x[^2,7]z#', '!', "$str");

# 3
# найти х, не б лат.буква 1 и более, z
# $str = 'x2z xAA1z x1z xQQ7z';
# echo preg_replace('#x[^A-Z]+z#', '!', "$str");

# 4
# найти х, не б лат.буква 1 и не мал. лат. буква 
# и не цифра от 1 до 5 один и более раз, z
# $str = 'x88z xAA1z x1z xQQ7z';
# echo preg_replace('#x[^A-Z,a-z,1-5]+z#', '!', "$str"); 



/** ОСОБЕННОСТИ КИРИЛЛИЦЫ В РЕГУЛЯРКАХ PHP 195/228 ✓ **/

// $res = preg_replace('#[а-яё]#u', '!', $str);
// [а-яё] - для обозн. кирилицы вместе с ё
// u - модификатор, для корректной работы кирилицы.

# ДЗ (особенности кирилицы)

# 1
# w, буквы кирилицы, w
# $str = 'wйw wяw wёw wqw';
# echo preg_replace('#w[а-яё]w#u', '!', "$str");

# 2 
# любая буква кирилицы, любое кол-во раз
# $str = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ';
# echo preg_replace('#[а-яё,А-ЯЁ]+#u', '!', "$str");



/** СПЕЦСИМВОЛЫ ВНУТРИ КВАДРАТНЫХ СКОБОК В PHP 196/228 ✓ **/

// [] - внутри их, спец.символы не надо экранировать 
// т.к они становятся обычными символами.

// Пример1
// между х, любая a b c либо точка
// $str = 'xax xbx xcx xdx x.x x@x';
// $res = preg_replace('#x[abc.]x#', '!', $str); 
// 

// Пример2
// между х, любая маленькая лат.буква или точка:
// $str = 'xax xbx x.x x@x';
// echo $res = preg_replace('#x[a-z.]x#', '!', $str);
// ! ! ! x@x


# ДЗ (спец.символы внутри квадратных скобок):

# 1
# найти 'a.a', 'a+a', 'a*a' - не затронув ост.
# $str = 'aba aea aca aza axa a.a a+a a*a'; 
# echo preg_replace('#a[+.*]a#', '!', "$str");

# 2
# x, не . @ $ , z
# $str = 'xaz x.z x3z x@z x$z xrz';
# echo preg_replace('#x[^.@$]z#', '!', "$str");



/** ГРУППЫ СИМВОЛОВ ВНУТРИ КВАДРАТНЫХ СКОБОК PHP 197/228 ✓ **/

// Группы символов \d, \D, \w, \W, \s, \S внутри [] 
// будут обозначать именно группы, то есть будут командами.

// Пример1
// $str = 'xax xbx x1x x2x xhx x@x';
// echo $res = preg_replace('#x[\d,a-f]x#', '!', $str);
// ! ! ! ! xhx x@x

// Пример2
// $str = 'xaz x1z xAz x.z x@z';
// $res = preg_replace('#x[^\d.a-z]z#', '!', $str);
// 'xaz x1z ! x.z !'


# ДЗ (Группы символов внутри кв.скобок РНР)

# 1
# цифра или точка от 1 и более раз.
# $str = 'xaz x111z xAz x..z x@z';
# echo preg_replace('#x[1-9,.]+z#', '!', "$str");

# 2
# не цифра и не буква от 'a' до 'g' от 3 до 7 раз.
# $str = 'xwwwwz x1z xAz x......z x@@@z';
# echo preg_replace('#x[^0-9,a-g]{3,7}z#', '!', "$str");
# т.е мы захватываем буквы и цифры когда их больше 3х но меньше 7
# а всё остальное(т.е символы, т.к они в [] то захват. по умолч.)



/** ИСКЛЮЧЕНИЯ ВНУТРИ НАБОРОВ В РЕГУЛЯРКАХ PHP 198/228 ✓ **/

// [] - если нам нужно чтобы квадратные скобки тоже были как симв.
// то их нужно экранировать:

// между "х", стоит квадратная скобка.
# $str = 'x]x xax x[x x1x';
# echo $res = preg_replace('#x[\[\]]x#', '!', $str);

# ДЗ (исключения внутри наборов в регулярках):

# 1
# x, любое кол-во любых скобок, z
# $str = 'x[]z x{{}}z x.z x()z';
# echo preg_replace('#x[{},(),\[\]]*z#', '!', "$str");

# 2
# строки в любых скобках и заменить на !
# $str = '[abc] {abc} abc (abc) [abc]'; 
# echo preg_replace('#^(abc) [abc] {abc}#', '!', "$str");



/** СИМВОЛ ШЛЯПКИ ВНУТРИ НАБОРОВ В РЕГУЛЯРКАХ PHP 199/228 ✓ **/

// ^ - чтобы получить шляпку, как символ, нужно или заэкранировать
// или убрать с первого места.

// Пример1
// перв символ это d или ^, потом две буквы хх
// убираем с первого места:
// $str = 'axx bxx ^xx dxx';
// preg_replace('#[d^]xx#', '!', $str); // ахх bxx ! !
// или [\^d], т.е экранируем.

# ДЗ (Символ шляпки внутри наборов в регулярках РНР):

# 1
# шляпка, или собака, две лат.буквы
# $str = '^xx axx ^zz bkk @ss';
# echo preg_replace('#[\^,@][a-z]{0,2}#', '!', "$str");

# 2
# не шляпка и не собака, две лат. буквы
# $str = '^xx axx ^zz qkk @ss';
# $res =  preg_replace('#[^\^,@][a-z]{3}#', '!', "$str");
# echo $res;

# 3
# не шляпка, две лат. буквы
# $str = '^xx axx ^zz bkk';
# $res =  preg_replace('#[\^][a-z]{2}#', '!', "$str");
# echo $res;



/** ДЕФИС ВНУТРИ НАБОРОВ В РЕГУЛЯРКАХ PHP 200/228 ✓ **/

// Внутри [] скобок, дефис "-", как и "^", работает как спец.символ.
// Если нужен "-" как символ, то экран. Или ставим в нач. или конце
// Пример:
// #1[az-]2#, #[a-z-0-9]x#, #[a-z-]x#, #1[a\-z]2#.
// в вышеуказ. случаях дефис будет обычным символом.

# ДЗ (дефис внутри наборов в регулярках php):

# 1
# $str = 'xaz xBz xcz x-z x@z';
# echo preg_replace('#x[a-z-A-z]z#', '!', "$str");

# 2
# $str = 'xaz x$z x-z xcz x+z x%z x*z';
# echo preg_replace('#x[$\-+]z#', '!', "$str");



/** НАЧАЛО И КОНЕЦ СТРОКИ В РЕГУЛЯРКАХ PHP 201/228 ✓ **/

// ^ - спец.символ также озн. начало строки (пишется в начале)
// $ - конец строки (пишется в конце)
// если  стоит ^вначале а $ в конце, то проверяем всю строку (Прим.3)

// Пример1
// заменить ааа, на !, только если ааа в начале строки:
// $str = 'aaa aaa aaa';    // ! ааа ааа
// $res = preg_replace('#^aaa#', '!', $str);

// Пример2
// заменить ааа, на !, только если ааа в конце строки:
// $str = 'aaa aaa aaa';    // ааа ааа !
// $res = preg_replace('#aaa$#', '!', $str);

// Пример3
// а один или более раз, заменить всю строку на !, только она сост
// из всех букв "а".
// $str = 'aaa';
// $res = preg_replace('#^a+$#', '!', $str); \\ !

# ДЗ (начало и конец строки)

# 1
# найти первую подстроку из букв:
# $str = 'abc def xyz';
# echo preg_replace('#^[a-z]+#', '!', "$str");

# 2
# найти последнюю подстроку из букв:
# $str = 'abc def xyz';
# echo preg_replace('#[a-z]+$#','!', "$str");

# 3
# проверим всю строку на соотв. регулярке.
# $str = 'abcdefxyz';
# echo preg_replace('#^[a-z]*$#','!', "$str"); // !



/** КОНЕЦ ИЛИ НАЧАЛО СЛОВА В РЕГУЛЯРКАХ PHP 202/228 ✓ **/

// "/b" - начало или конец слова. (\В с приставкой "не")

// Пример1:
// начало слова, мал. буквы один или боле раз, конец слова:
// $str = 'axx bxx xxx exx';
// echo preg_replace('#\b[a-z]+\b#', '!', "$str"); // выведет ! ! !

# ДЗ (конец или начало слова в регулярках)

# 1
# найти: буква "х", в начале слова:
# ОБРАТИТЬ ВНИМАНИЕ!!
# $str = 'aaa xaa aaa xbb aax';
# echo preg_replace('#\bx\w*\b#','!',"$str");



/** КОМАНДА 'ИЛИ' В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ PHP 203/228 ✓ **/

// "|" - команда "или", как в условиях (мощнее чем [])
// позволяет разделить регулярку на несколько частей.


// Пример1:
// три буквы "а" или три буквы "б";
// $str = 'aaa bbb abb';
// $res = preg_replace('#a{3}|b{3}#','!',"$str");	
// echo $res;	// ! ! abb

// Пример2
// три буквы "а", или от 1 и более букв "б"
// $str = 'aaa bbb bbbb bbbbb axx';
// $res = preg_replace('#a{3}|b+#','!',"$str");	
// echo $res;

// Пример3:
// одна или более буквы или три цифры:
// $str = 'a ab abc 1 12 123';
// $res = preg_replace('#[a-z]+|\d{3}#','!',"$str");
// echo $res;

// Пример4:
// "|" - делит регулярку, не на 2 части, а на любое кол-во частей
// $str = 'aaa bbb ccc ddd';
// $res = preg_replace('#a+|b+|c+#', '!', $str);

// Пример5
// "|" - работает, только внутри () скобок, то и работает только там
// найти: в начале "а" или "б" один или более , потом две буквы "х"
// $str = 'axx bxx bbxx exx';
// $res = preg_replace('#(a|b+)xx#', '!', $str);


# ДЗ (команда ИЛИ в регулярных выражениях):

# 1
# по краям стоят "а", между ними или "е" - любое кол-во, 
# или "х" любое кол-во раз.
# $str = 'aedeea aeea aea axa axxa axxxa';
# echo preg_replace('#a(e*|x*)a#', '!', "$str");

# 2 
# по краям а, между ними е два раза или буква х любое кол-во раз.
#$str = 'aeeea aeea aea axa axxa axxxa';
#echo preg_replace('#a(e{2}|x*)a#','!',"$str");



/** ОГРАНИЧИТЕЛИ РЕГУЛЯРОК В PHP 204/228 ✓ **/

// В качестве ограничителей могут выступать не только #
// Но и любые другие символы (только не буквы и не цифры).

// Пример:
// echo preg_replace('&а+&', '!', 'строка');
// или '(a+)', тоже могут быть ограничителями.

# ДЗ (ограничители регулярок в РНР):

# 1
# исп-ть символ ~ в качестве разделителя
# echo preg_replace('~а+~', '!', 'строка'); // строк!



/** ЭКРАНИРОВКА ОГРАНИЧИТЕЛЕЙ В PHP 205/228 ✓ **/

// Если символ, не яв. спец. то когда мы исп. для ограничителя
// его надо экранировать в регулярке:
// #a&b#  - тут не надо экранировать
// &a\&b& - тут надо экранировать

# ДЗ (экранировка ограничителей):

# 1
# исправил ошибку, заэкранировал:
# echo preg_replace('#a\#b#', '!', 'a#b');



/** ПРОБЛЕМА ОБРАТНОГО СЛЕША В PHP 206/228 ✓ **/

// "\" - обр.слеш, спец.символ,чтобы он обозн.сам себя его над удв-ть
// "\" - также яв. спец.симв. регулярок, поэтому тоже экранируется

// Пример:
// обратный слеш один или более раз.
// Мы напишем оператор "+", для 4 символов перед ним без группировки:
// preg_replace('#\\\\+#', '!', '\\ \\\\ \\\\\\');

# ДЗ (проблема обратного слэша):
# 1
# буква, \, буква
# $str = 'a\\b c\\d e\\f';
# echo preg_replace('#[a-z]\\\\[a-z]#','!',"$str");

# 2
# буква, \(любое кол-во раз), буква
# $str = 'a\\b c\\\\d e\\\\\\f';
# echo preg_replace('#[a-z]\\\\*[a-z]#','!',"$str");



/** ПРОВЕРКА СТРОКИ С ПОМОЩЬЮ РЕГУЛЯРКИ НА PHP 207/228 ✓ **/

// preg_match - проверяет совпадение с регуляркой.
// preg_match(регулярка, строка для поиска);

// Если совпадений много - фу-я, найдет 1е и закончит работу.
// Поэтому фу-я выводит либо 1, либо 0, используется для ответа
// есть искомое в строке или нет.

// Пример1:
// $str = 'eee aaa bbb';
// $expr = '#a+#';
// $res = preg_match($expr, $str);
// echo $res; // выведет 1

// Пример2
// $str = 'eee bbb';
// $expr = '#a+#';
// $res = preg_match($expr, $str);
// echo $res; // выведет 0

# ДЗ (проверка на строки с помощью регулярки):

# 1
# Определите, есть ли в строке 3 цифры подряд:
# $str = '135 aaa bbb';
# $expr = '#\d{3}#';
# $res = preg_match($expr, $str);
# echo $res;		// 1

# 2
# Определите, начинается ли переданная строка с http.
# и заканчивается в т.ч:
# echo preg_match('#^http#','http aaa bbb'); // 1
# echo preg_match('#http$#','http aaa bbb'); // 1

# 3
# Определите, начинается ли переданная строка с http или с https.
# echo preg_match('#^(http)|(https)#','https aaa bbb'); // 1

# 4 
# Определите, заканчивается ли переданная строка расширением 
# txt, html или php.
# echo preg_match('#(html)|(txt)|(php)$#','http aaa html'); // 1

# 5 
# Определите, заканчивается ли 
# переданная строка расширением jpg или jpeg.
# echo preg_match('#(jpeg)|(jps)$#','http aaa html'); // 0


/** АВТОМАТИЧЕСКОЕ ТЕСТИРОВАНИЕ РЕГУЛЯРОК В PHP 208/228 ✓ **/

// Напишем код, который позволит удобно тестировать регулярки
// на нескольких строках кода:

// $reg = '#\d{3,}#'; // регулярка которая будет тестировать.

// Массив строк кода, для проверок:
// $arr[] = 'aaa 123 bbb';
// $arr[] = 'aaa 12345 bbb';
// $arr[] = 'aaa 12x bbb';
// $arr[] = 'aaa 12 bbb';

// Переберем этотм массив циклом, проверяя каждый эл. регуляркой:
// foreach ($arr as $str) {
// 	$res = preg_match($reg, $str);
// 	echo 'Рез. строки: ' . "'$str' " . 'будет:' ." $res" . '<br>'; 
// }

// На выводе будет:
// Рез. строки: 'aaa 123 bbb' будет: 1
// Рез. строки: 'aaa 12345 bbb' будет: 1
// Рез. строки: 'aaa 12x bbb' будет: 0
// Рез. строки: 'aaa 12 bbb' будет: 0

# ДЗ (Автоматическое тестирование регулярок):

# 1
# проверить, есть ли в строке дробное число
# исп-я наш скрипт, проверить регулярку на разл.строках.

# тут получ. просто пишем "число+ и точку и еще число+":
# $reg = '#[0-9]+\.[0-9]+#'; 

# $arr[] = 'aaa 123 bbb';
# $arr[] = 'aaa 123.45 bbb';
# $arr[] = 'aaa 12x bbb';
# $arr[] = 'aaa 12 bbb';

# foreach ($arr as $str) {
# 		$res = preg_match($reg, $str);
# 			echo 'Рез. строки: ' . "'$str' " . 'будет:' .
# 			" $res" . '<br>';
# 	}

# Рез. строки: 'aaa 123 bbb' будет: 0
# Рез. строки: 'aaa 123.45 bbb' будет: 1
# Рез. строки: 'aaa 12x bbb' будет: 0
# Рез. строки: 'aaa 12 bbb' будет: 0



/** ПРОВЕРКА ВСЕЙ СТРОКИ ЧЕРЕЗ РЕГУЛЯРКИ В PHP 209/228 ✓ **/

// preg_match() - позв. проверить всю ^строку$ на соотв. регулярке

// Пример1:
// preg_match('#^a+$#', 'aaa'); // 1
// preg_match('#^a+$#', 'aab'); // 0

# ДЗ (проверка всей строки через регулярки в РНР):

# 1
# опр, явл. ли перед. строка доменом:
# $arr[] = 'site.ru';          
# $arr[] = 'site.com';         
# $arr[] = 'my-site.com';      
# $arr[] = 'my-cool-site.com'; 
# $arr[] = 'my_site.com';      
# $arr[] = 'site123.com';      
# $arr[] = 'site.travel';      
# $arr[] = 'site.r';           
# $arr[] = 'si$te.com';
 
# $reg  = '#^[a-z,0-9\-_]+\.[a-z]{2,}$#';

# foreach ($arr as $str) {
# 	$res = preg_match($reg, $str);
# 	echo 'рез. строки: ' . "$str" . ' будет равен: ' . "$res" . '<br>';
# }

# 2
# опр. явл. ли перед. строка email:
# $arr[] = 'addr@mail.ru';    // +
# $arr[] = 'addr123@mail.ru'; // +
# $arr[] = 'my-addr@mail.ru'; // +
# $arr[] = 'my_addr@mail.ru'; // +
# $arr[] = 'addr@site.ru';    // +
# $arr[] = 'addr.ru';         // -
# $arr[] = 'addr@.ru';        // -
# $arr[] = 'my@addr@mail.ru'; // -

# $reg = '#^[a-z,0-9,\-,_]+@[a-z]+\.[a-z]{2,}$#';

# foreach ($arr as $str) {
# 	$res = preg_match($reg, $str);
# 	echo 'у строки: ' . "$str" . 'результат: ' . "$res" . '<br>';
# }



/** КАРМАНЫ ПРИ ПОИСКЕ ЧЕРЕЗ РЕГУЛЯРКИ НА PHP 210/228 ✓ **/

// есть строка содержащая домен:
// $str = 'my_site.ru';

// напишем регулярку, которая находит этот домен:
// $reg = '#[a-z,\-,_]+\.[a-z]{2,}#';

// напишем "карманы рег.выраж", отделим имя домена от его зоны. с пом()
// "карманы" - эл-ты массива в кот. можно положить части, найд. рег. :
// $arr = '#([a-z,\-,_]+)\.([a-z]{2,})#';

// теперь в фу-ии preg_match в качестве пара-ра укажем перемен:
// preg_match($reg, $str, $arr);

// в $arr попадет массив с "карманами". В нул-вом эл-те будет лежать 
// строка, в 1-ом эл-те 1-й карман, во 2-ом эл-те 2-ой карман
// var_dump($arr); // ['my_site.ru', 'my_site', 'ru'];

# ДЗ (Карманы при поиске)

# 1
# положить, год-месяц-день в отдельные карманы:
# $str = '2025-12-31';
# $reg = '#([0-9]{0,4})-([0-9]{0,2})-([0-9]{0,2})#';
# $res = preg_match($reg, $str, $arr);
# var_dump($arr);

# 2
# положите имя файлы и его расширение в отдельные карманы:
# $str = 'index.html';
# $reg = '#([a-z]+)\.([a-z]{2,})#';
# $res = preg_match($reg, $str, $arr);
# var_dump($arr);



/** ПОИСК ВСЕХ СОВПАДЕНИЙ ЧЕРЕЗ РЕГУЛЯРКИ НА PHP 211/228 ✓ **/

// preg_match_all() - кол-во совпадений с рег.выражением

# ДЗ (кол-во совпадений):
# $str = '112 312 412 351';
# т.е, если у нас в строке 4 пробела, зн 4 числа, зн 4 совпадения:
# $res = preg_match_all('#[0-9]+#', $str);
# echo $res; // 4



/** ВСЕ СОВПАДЕНИЯ НА КАРМАНЫ ЧЕРЕЗ РЕГУЛЯРКИ В PHP 212/228 ✓ **/

// preg_match_all() - даёт возможность разделить, ВСЕ НАЙДЕННЫЕ 
// СОВПАДЕНИЕ на карманы.

// строка с доменами:
// $str = 'site.ru site123.com my-site.net';
 
// отделим имя и зону на карманы:
// $reg = '#([a-z0-9_-]+)\.([a-z]{2,})#';

// запишем в массив:
// preg_match_all($reg, $str, $res);

// в рез-тате получим двухмерный массив:
// [
//     ['site.ru', 'site123.com', 'my-site.net'], //попало под всё
//     ['site', 'site123', 'my-site'], // содерж. 1-го кармана
//     ['ru', 'com', 'net'], // содерж. 2-го кармана
// ]

# ДЗ (Все совпадения на карманы, через регулярки в РНР):

# 1
# найти все даты, отделив, год и месяц в отдельные карманы:
# $str = '2023-10-29 2024-11-30 2025-12-31';
# $reg = '#([0-9]{0,4})-([0-9]{0,2})-([0-9]{0,4})#';
# preg_match_all($reg, $str, $arr);
# var_dump($arr);



/** ИЗМЕНЕНИЕ ПОВЕДЕНИЯ PREG_MATCH_ALL В PHP 213/228 ✓ **/

# 1
# Найти все даты, отделив, год и месяц в отдельные карманы.
# Далее модифицируйте задачу так, чтобы в первый под-массив попала
# Первая дата с карманами, во второй подмассив - вторая дата итд

# $str = '2023-10-29 2024-11-30 2025-12-31';
# $reg = '#([0-9]{4})-([0-9]{2})-([0-9]{2})#';
# $res = preg_match_all($reg, $str, $arr, $matches = 2); 
# var_dump($arr);

# preg_match_all() состоит из 
# $reg - регулярка (шаблон для поиска)
# $str - строка в которой ищем
# $matches - массив, в который будут записаны результаты поиска
# $flags - флаги изменяющие поведение функции.

# PREG_PATTERN_ORDER (значение 1, т.е по умолчанию) - 
# результаты будут разбиты на четыре массива: 
# полное вхождение и три подшаблона. 

# PREG_OFFSET_CAPTURE (значение 2) -  
# результаты будут разбиты на три массива, 
# каждый из которых будет содержать пары "значение-позиция" 
# для каждого из подшаблонов.



/** НЕСОХРАНЯЮЩИЕ СКОБКИ В РЕГУЛЯРКАХ PHP 214/228 ✓ **/

// (?:) - не сохраняющиеся скобки, группируют но не кладут в карман.

// Пример1:
// сделаем, так чтобы в карман попала только первая пара:
// $str = 'abab123';
// $reg = '#(ab)+(?:[1-9]+)#';

# ДЗ (не сохраняющие скобки в регулярках):

# Найти каждую из подстрок.
# В 1й карман, положите то, что стоит до разделителя.
# А во второй карман, то что стоит после разделителя.

# $str = 'aaa$@bbb aaa$@$@bbb aaa$@$@$@bbb';
# $reg = '#([a-z]+)(?:[$@]+)([a-z]+)#';
# preg_match_all($reg, $str, $arr, 1);
# var_dump($arr);



/** КАРМАНЫ ПРИ ЗАМЕНЕ ЧЕРЕЗ РЕГУЛЯРКИ НА PHP 215/228 ✓ **/

// preg_replace() - с ее пом. можем вставить содержимое опр.кармана.
// написав $ и номер кармана. ($0 - нулевой карман, $1 - 1й, итд).

// Пример1:
// $str = '1 23 456 xax';
// $res = preg_replace('#(\d+)#', '{$1}', $str);
// '{1} {23} {456} xax'

// Пример2:
// $str = 'x1x x23x x456x xax';
// $res = preg_replace('#x(\d+)x#', '!$1!', $str);
// '!1! !23! !456! xax

// Пример3:
// $str = 'aaa@bbb ccc@ddd';
// $res = preg_replace('#([a-z]+)@([a-z]+)#', '$2@$1', $str);
// 'bbb@aaa ddd@ccc'

# ДЗ (Карманы при замене через регулярки на PHP):

# 1
# Поменяйте местами цифры во всех двухзначных числах.
# $str = '12 34 56 78';
# $reg = '#(\d+)(\d+)#';
# echo preg_replace($reg, '$2 $1', $str);

# 2
# Преобразовать дату в "2025.12.31"
# $str = '31.12.2025';
# $reg = '#([0-9]{2})\.([0-9]{2})\.([0-9]{4})#';
# $res = preg_replace($reg, '$3.$2.$1', $str);
# echo $res;



/** КАРМАНЫ В РЕГУЛЯРНОМ ВЫРАЖЕНИИ В PHP 216/228 ✓ **/

// Содержимое карманов, также доступно и в регулярке.
// Мы можем положить что-то в карман, а затем прямо в регулярке
// Сказать, что здесь должно стоять содержимое этого кармана.
// (нулевой карман 0й - \0, 1й - \1, 2й - \2)

# Пример1
# найти места, в которых стоят 2 любые одинаковые буквы подряд.
# $str = 'aa bb cd ef';
# echo preg_replace('#([a-z]+)\g1#','!', $str);
# мы берем любую букву и кладём в карман
# затем проверяем идет следующим символом содержимое этого кармана.
# если идёт - тогда "хапаем"

# Пример2
# найти в $str слова, в которых одинаковы первая и последняя буквы.
# $str = 'asxca buzxb csgd';
# echo preg_replace('#([a-z])[a-z]+\g1#', '!', $str);
# буква, затем еще буква или более букв, затем такая же как и 1-я.

# * в фигурных скобках можно писать так: g{-2} (тогда карманы будут
# отсчитываться с конца).

# ДЗ (КАРМАНЫ В РЕГУЛЯРНОМ ВЫРАЖЕНИИ РНР):

# 1
# $str = 'aa bbb cccccc xyz';
# echo preg_replace('#([a-z])+\g1#','!', $str);
# это выражение работает на любое кол-во раз
# и проверяет не букву, как раньше , а содержимое кармана.

# 2
# $str = 'a aa aaa abab bbbb';
# echo preg_replace('#([a-z]{2,})+\g1#', '!', $str);
# а тут уже берем на проверку сразу 2 буквы

# 3
# $str = 'aaa aaa bbb bbb ccc ddd';
# найти два одинаковых слова подряд.
# echo preg_replace('#(\b[a-z]+\s*\b)+\g1#', '!', $str);



/** ИМЕНОВАННЫЕ КАРМАНЫ В РЕГУЛЯРКАХ PHP 217/228 ✓ **/

// $str = '2025-10-29';
// Чтобы дать имя карманам исп. схему (?<name>pattern)
// $reg = '#(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})#';
// preg_match($reg, $str, $match);
// var_dump($match);

// в результате получим ассоц. массив. в котором ключами будут -
// имена карманов, а значениями, - что в них попало:

// 0 => string '2025-10-29' (length=10)
// 'year' => string '2025' (length=4)
// 1 => string '2025' (length=4)
// 'month' => string '10' (length=2)
// 2 => string '10' (length=2) и.т.д

// 2025 будет доступен, как и по 'year', так и по 1
// * еще для них синтаксис (?P<name>pattern) и (?'name'pattern).

# ДЗ (именованные карманы в регулярках)

# 1
# Положить часы, минуты и секунды в отд.имен. карманы:
# $str = '12:54:59';
# $reg = '#(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)#';
# $res = preg_match($reg, $str, $arr);
# var_dump($arr);

# 2
# Напишите функцию, которая в массиве с результатом удалит все
# нумерованные карманы, оставив только именованные.
/*
$str = '12:54:59';
$reg = '#(?<hours>\d+):(?<minutes>\d+):(?<seconds>\d+)#';
$res = preg_match($reg, $str, $arr);
function delNumArr($arr){
	foreach ($arr as $key => $elem) {
		if (is_int($key)){
			// Чтобы удалить обр. по ключу:
			unset ($arr[$key]);
		}
	}
	return $arr;
}
$assocArr = delNumArr($arr);
var_dump($assocArr);
*/



/** ИМЕНОВАННЫЕ КАРМАНЫ ВНУТРИ РЕГУЛЯРКИ PHP 218/228 ✓ **/

/*
 *  Дадим имя карману:
 * 	$res = preg_replace('#(?<letter>[a-z])#', '!', $str);
 *  Иногда удобнее обращаться к карману по имени:
 *  preg_replace('#(?<letter>[a-z])\g<letter>#', '!', $str);
 *  Альтернативный синтаксис, кармана:
 *  (?P=name), \g{name}, \g'name', \k<name>, \k'name', \k{name}
*/

# 1
# найти все подстроки со временем где час совпадает с секундами:
# $str = '12:59:59 12:59:12 09:45:09';
# $reg = '#([0-9]{2}):[0-9]{2}:\k#';
# echo preg_replace($reg, '!', $str);
# ОБРАТИТЬ ВНИМАНИЕ НА СИНТАКСИС! работает только c "\k"!



/** ОБЩИЙ НОМЕР КАРМАНОВ В РЕГУЛЯРКАХ PHP 219/228 ✓ **/

// например у нас есть переменая с годом.
// и нам надо получить последние две цифры года в карман.
// $year = mt_rand(1990, 2099);
// $reg = '#(?|19(9\d)|20(\d\d))#';
// preg_match($reg, $year, $arr);
// var_dump($arr);

// проблема: когда 1990й, то будет попадать в 1й карман
// 0 => string '1998' (length=4)
// 1 => string '98' (length=0)
// а когда 2000е то попадает во второй карман
// 2 => string '' (length=2)

// если нам надо записать найденное число в перем
// то мы не знаем точно, с каким ключом забирать данные из кармана.
// $res = $arr[1]; // или $arr[2]

// поэтому с помощью команды "?|" - '#(?|19(9\d)|20(\d\d))#'
// и теперь все карманы, будут иметь 1 номер (1й)
// $res = $arr[1]

# ДЗ (общий номер карманов):

# Для каждой даты положите день в первый карман, месяц во второй
# А последние две цифры года - в трейтий.
# $date = ['31-12-2025',' 30-11-1995', '29-10-1990',];
/*
foreach ($date as $str) {
$reg = '#([0-9]{2})-([0-9]{2})-(?|(?:20|19)([0-9]{2}))#';
preg_match($reg, $str, $arr);
var_dump($arr);
} */



/** ПОЗИТИВНЫЙ И НЕГАТИВНЫЙ ПРОСМОТР В PHP 220/228 ✓ **/

# позит. про-р. впер. - если ПОСЛЕ "ааа" стоит "х"
# ааа(?=х) - то захватывает всё кроме "х".

# позит. про-р. наз. - если ПЕРЕД "ааа" стоит "х"
# (?<=x)ааа - то захв. всё кроме "х".

# негат. про-р вперед - если после. "ааа"  НЕ СТОИТ "х"
# aaa(?!x) - то захв. всё кроме "х".

# негат. про-р наз. - если перед "ааа" НЕ СТОИТ "х"
# (?<!x)aaa - то захв. всё кроме "х".


# ДЗ (позитивный и негативный просмотр):
# 1
# Дана строка, содержащая имена функций.
# Получите массив имен функций из строки.
/*
$str = 'func1() func2() func3()';
$reg = '#[a-z]+\d#';
preg_match_all($reg, $str, $res);
foreach ($res as $elem) {
	var_dump($elem);
}
*/
# 2
# получите массив имен атрибутов этого тега
/*
$str = '<a href="" class="eee" id="zzz">';
$reg = '#(?<=[a-z]=)+"[a-z]*#';
preg_match_all($reg, $str, $res);
foreach ($res as $elem) {
	var_dump($elem);
}
*/
# 3
# получите массив имен переменных из этой строки (без доллара)
/*
$str = '$aaa $bbb $ccc';
$reg = '#(?<=\$)[a-z]+#';
preg_match_all($reg, $str, $res);
foreach ($res as $elem) {
	var_dump($elem);
}
*/



/** ЗАМЕНА С КОЛЛБЭКОМ ЧЕРЕЗ РЕГУЛЯРКИ В PHP 221/228 ✓ **/

# Надо найти  "число+число=" в $str и результат сложения чисел.
# $str = '2+3= 3+5= 7+8=';
# $reg = '#(\d+)\+(\d+)=#';
# $res = preg_replace_callback($reg,
// callback - фу-я, кот. выз. для каждого совпадения
# function ($match) {
// $match - выступает, как массив, в который записываются рез-ты
// карманов найденного.
# 	return $match[0] . ($match[1] + $match[2]) . '<br>';
# }, $str);
# echo $res;
// 2+3=5
// 3+5=8
// 7+8=15

# ДЗ (замена с колбэком через регулярки).
# 1
# Преобразовать строку так, чтобы вместо этих чисел стояли их квад.
/*
$str = '1 2 3 4 5';
$reg = '#\d+#';
$res = preg_replace_callback($reg,
function ($arr) {
	return $arr[0] * $arr[0] . '<br>';
}
, $str);
echo $res;
*/



/**  МОДИФИКАТОРЫ РЕГУЛЯРОК В PHP 222/228 ✓ **/
// Модификаторы это ##, .. итд. Посмотрим что можно с ними сделать



/**  ИГНОРИРОВАНИЕ РЕГИСТРА РЕГУЛЯРОК В РНР 223/228 ✓ **/

// echo preg_replace('#[a-z]+#i', '!', 'aaa bbb AAA');
// i - позволяет игнорировать регистр



/**  КОММЕНТАРИИ В РЕГУЛЯРКЕ В PHP 224/228 ✓ **/

// x - раз. расставлять в регулярке произв. проб. и переводы строк.
// # - становится комментарием. соотв. ограничитель надо менять.
/*
$res = preg_replace('~
[a-z]+ # буквы
@      # символ собаки
[0-9]+ # цифры
~x', '!', 'aaa@333');
echo $res;
*/



/**  РАБОТА С ЮНИКОДОМ В РЕГУЛЯРКАХ В PHP 225/228 ✓ **/

// u - как мы уже помним, позв. корректно отрабатывать кирилицу.



/**  ИЗМЕНЕНИЕ ЖАДНОСТИ РЕГУЛЯРОК В PHP 226/228 ✓ **/

// preg_replace('#x.+x#U', '!', 'xaxxaax xaaax')
// U - сделает, так чтобы все операторы повторений станут
// по умолчанию - не жадными.
// А добавление "?" - наоборот, будет добавлять им жадности.



/**  ЭКРАНИРОВКА ОБЫЧНЫХ СИМВОЛОВ В РЕГУЛЯРКАХ В PHP 227/228 ✓ **/

// Х - не даёт экранировать обычный символ.
// preg_replace('#x\@x#X', '!', 'x@x');// ошибка, @ не спецсимвол



/**  НЕСКОЛЬКО МОДИФИКАТОРОВ РЕГУЛЯРОК В PHP 228/228 ✓ **/

// модификаторы можно комбинировать:
// #[a-z]+#iU
// #[a-z]+#Xx
// #[а-яё]+#ui
// и.т.д

